<!DOCTYPE html>
<html>
<head>
    <title>Feature Setup</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <div class="dark-mode-toggle">
        <label class="switch">
            <input type="checkbox" id="darkModeToggle">
            <span class="slider"></span>
        </label>
        <span>Dark Mode</span>
    </div>
    <div class="version-info">
        <div>Version {{FW_VERSION}}</div>
        <div>Build {{FW_BUILD_TIME}}</div>
    </div>

    <div class="header-container">
        <h1 class="main-title">‚öôÔ∏è Feature Setup</h1>
        <p>Enable or disable individual features for your doorbell.</p>
    </div>

    <div class="dashboard">
        <div class="container card setup-card">
            <h3 class="card-title">üîß Core Features</h3>
            <div class="info-grid">
                <div class="info-item">
                    <span><strong>üåç Timezone</strong></span>
                </div>
                <select id="timezone" style="grid-column: 1 / -1; margin-bottom: 12px;">
                    <option value="PST8PDT,M3.2.0,M11.1.0">üá∫üá∏ Pacific Time (US & Canada)</option>
                    <option value="MST7MDT,M3.2.0,M11.1.0">üá∫üá∏ Mountain Time (US & Canada)</option>
                    <option value="CST6CDT,M3.2.0,M11.1.0">üá∫üá∏ Central Time (US & Canada)</option>
                    <option value="EST5EDT,M3.2.0,M11.1.0">üá∫üá∏ Eastern Time (US & Canada)</option>
                    <option value="AKST9AKDT,M3.2.0,M11.1.0">üá∫üá∏ Alaska Time</option>
                    <option value="HST10">üá∫üá∏ Hawaii-Aleutian Time (No DST)</option>
                    <option value="GMT0BST,M3.5.0/1,M10.5.0">üá¨üáß UK Time (GMT/BST)</option>
                    <option value="CET-1CEST,M3.5.0,M10.5.0/3">üá™üá∫ Central European Time</option>
                    <option value="EET-2EEST,M3.5.0,M10.5.0/3">üá™üá∫ Eastern European Time</option>
                    <option value="WET0WEST,M3.5.0/1,M10.5.0">üá™üá∫ Western European Time</option>
                    <option value="JST-9">üáØüáµ Japan Standard Time (No DST)</option>
                    <option value="CST-8">üá®üá≥ China Standard Time (No DST)</option>
                    <option value="AEST-10AEDT,M10.1.0,M4.1.0/3">üá¶üá∫ Australian Eastern Time</option>
                    <option value="ACST-9:30ACDT,M10.1.0,M4.1.0/3">üá¶üá∫ Australian Central Time</option>
                    <option value="AWST-8">üá¶üá∫ Australian Western Time (No DST)</option>
                    <option value="NZST-12NZDT,M9.5.0,M4.1.0/3">üá≥üáø New Zealand Time</option>
                </select>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666; grid-column: 1 / -1;">
                    Automatically handles daylight saving time transitions for your region.
                </div>
                <div class="info-item">
                    <span><strong>‚òéÔ∏è SIP Phone Ringing</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="sip_enabled" {{SIP_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    Ring FRITZ!Box phones when doorbell is pressed via SIP protocol.
                </div>

                <div class="info-item">
                    <span><strong>üì° TR-064 Integration</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="tr064_enabled" {{TR064_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    Enable TR-064 SOAP protocol for advanced FRITZ!Box control.
                </div>

                <div class="info-item">
                    <span><strong>üìπ HTTP Camera Streaming</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="http_cam_enabled" {{HTTP_CAM_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    MJPEG stream at http://ESP32-IP:81/stream and snapshot endpoint.
                </div>
                <div class="info-item">
                    <span><strong>üë• Max MJPEG Clients</strong></span>
                    <input type="number" id="http_cam_max_clients" min="1" max="4" value="{{HTTP_CAM_MAX_CLIENTS}}" style="width: 80px;">
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    Limit simultaneous HTTP stream clients (e.g., Scrypted + FRITZ!Box).
                </div>

                <div class="info-item">
                    <span><strong>üé• RTSP Camera Streaming</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="rtsp_enabled" {{RTSP_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    RTSP stream at rtsp://ESP32-IP:8554/mjpeg/1 (experimental, use HTTP for Scrypted).
                </div>

                <div class="info-item">
                    <span><strong>üîä Audio Out (Gong)</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="audio_out_enabled" {{AUDIO_OUT_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                    Local gong playback via MAX98357A I2S DAC.
                </div>
            </div>
        </div>

        <div class="container card setup-card">
            <h3 class="card-title">üì∑ Camera Config</h3>
            <div class="flash-stats" id="cameraSetupStatus">
                <strong>Camera:</strong> loading...
            </div>

            <label><strong>Frame Size</strong></label>
            <select id="framesize">
                <option value="5">QVGA (320x240)</option>
                <option value="6">CIF (400x296)</option>
                <option value="7">HVGA (480x320)</option>
                <option value="8">VGA (640x480)</option>
            </select>

            <label><strong>JPEG Quality</strong></label>
            <div class="range-wrap">
                <input type="range" id="quality" class="range-input" min="4" max="63" value="10">
                <span class="range-value" id="qualityValue">10</span>
            </div>

            <label><strong>Brightness</strong></label>
            <div class="range-wrap">
                <input type="range" id="brightness" class="range-input" min="-2" max="2" step="1" value="0">
                <span class="range-value" id="brightnessValue">0</span>
            </div>

            <label><strong>Contrast</strong></label>
            <div class="range-wrap">
                <input type="range" id="contrast" class="range-input" min="-2" max="2" step="1" value="0">
                <span class="range-value" id="contrastValue">0</span>
            </div>
        </div>

        <div class="container card setup-card">
            <h3 class="card-title">üîä Audio and üé§ Mic config <span id="audioSaveStatus" style="font-size:0.7em;font-weight:normal;color:#4caf50;opacity:0;transition:opacity 0.4s;"></span></h3>

            <div class="info-grid">
                <div class="info-item">
                    <span><strong>üîá Audio Out Mute</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="audio_out_muted" {{AUDIO_OUT_MUTED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="info-item">
                    <span><strong>üîä Audio Out Volume</strong></span>
                    <div class="range-wrap">
                        <input type="range" id="audio_out_volume" class="range-input" min="0" max="100" value="{{AUDIO_OUT_VOLUME}}" data-unit="%">
                        <span class="range-value" id="audioOutVolumeValue">{{AUDIO_OUT_VOLUME}}</span>
                    </div>
                </div>
                <div class="info-item">
                    <span><strong>üß™ Hardware Diagnostic Mode</strong></span>
                    <label class="switch">
                        <input type="checkbox" id="hardware_diag_mode">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                When enabled, Test Gong runs a 1 kHz diagnostic tone and logs detailed audio TX telemetry.
            </div>

            <label class="card-group-title" style="margin-top: 12px;"><strong>üé§ Microphone</strong></label>
            <div class="info-grid">
                <div class="info-item">
                    <span>Mic enabled</span>
                    <label class="switch">
                        <input type="checkbox" id="mic_enabled" {{MIC_ENABLED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="info-item">
                    <span>Mic mute</span>
                    <label class="switch">
                        <input type="checkbox" id="mic_muted" {{MIC_MUTED_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <label><strong>Mic Source</strong></label>
            <select id="mic_source">
                <option value="0">Onboard PDM (default)</option>
                <option value="1">External INMP441 (IP44 enclosure)</option>
            </select>
            <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                INMP441 uses shared I2S clock lines (GPIO7/GPIO8) with separate data lines. Requires reboot to take effect.
            </div>
            <label><strong>Mic Sensitivity</strong></label>
            <div class="range-wrap">
                <input type="range" id="mic_sensitivity" class="range-input" min="0" max="100" value="{{MIC_SENSITIVITY}}" data-unit="%">
                <span class="range-value" id="micSensitivityValue">{{MIC_SENSITIVITY}}</span>
            </div>
            <label><strong>AAC Stream Sample Rate</strong></label>
            <select id="aac_sample_rate">
                <option value="16" {{AAC_RATE_16_SELECTED}}>16 kHz (recommended)</option>
                <option value="8" {{AAC_RATE_8_SELECTED}}>8 kHz (lower bandwidth)</option>
            </select>

            <label><strong>AAC Bitrate</strong></label>
            <div class="range-wrap">
                <input type="range" id="aac_bitrate" class="range-input" min="16" max="48" value="{{AAC_BITRATE}}" data-unit="kbps">
                <span class="range-value" id="aacBitrateValue">{{AAC_BITRATE}}</span>
            </div>
            <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                16 kHz supports 24‚Äì48 kbps, 8 kHz supports 16‚Äì32 kbps. Preview mic capture at http://ESP32-IP/audio.wav.
            </div>
            <div class="button-row button-grid" style="margin-top: 8px;">
                <button class="button btn-test" title="Play the local gong through MAX98357A speaker output." onclick="testLocalGong()">üîî Test Gong</button>
                <button class="button btn-test" id="testMicBtn" title="Record 2s from mic and play back through speaker." onclick="testMic()">üé§ Record &amp; Play</button>
            </div>
            <div id="micTestResult" style="font-size:0.85em;padding:4px 8px;margin-top:4px;display:none;border-radius:4px;border:1px solid rgba(128,128,128,0.35);"></div>
        </div>

        <div class="container card setup-card">
            <h3 class="card-title">üì∫ Scrypted Stream Options</h3>
            <div class="flash-stats" id="scryptedStatus">
                <strong>Status:</strong> loading...
            </div>

            <label class="card-group-title"><strong>Source Type</strong></label>
            <div class="info-grid">
                <div class="info-item">
                    <span>HTTP MJPEG</span>
                    <input type="radio" name="scrypted_source" id="scrypted_source_http" value="http" {{SCRYPTED_SOURCE_HTTP_CHECKED}}>
                </div>
                <div class="info-item">
                    <span>RTSP MJPEG</span>
                    <input type="radio" name="scrypted_source" id="scrypted_source_rtsp" value="rtsp" {{SCRYPTED_SOURCE_RTSP_CHECKED}}>
                </div>
            </div>

            <label class="card-group-title" style="margin-top: 12px;"><strong>Optimization</strong></label>
            <div class="info-grid">
                <div class="info-item">
                    <span>Low latency (short GOP)</span>
                    <label class="switch">
                        <input type="checkbox" id="scrypted_low_latency" {{SCRYPTED_LOW_LATENCY_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="info-item">
                    <span>Reduce input buffering</span>
                    <label class="switch">
                        <input type="checkbox" id="scrypted_low_buffer" {{SCRYPTED_LOW_BUFFER_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="info-item">
                    <span>Prefer RTSP UDP transport</span>
                    <label class="switch">
                        <input type="checkbox" id="scrypted_rtsp_udp" {{SCRYPTED_RTSP_UDP_CHECKED}}>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <label class="card-group-title" style="margin-top: 12px;"><strong>Doorbell Webhook (HomeKit)</strong></label>
            <input type="text" id="scrypted_webhook" value="{{SCRYPTED_WEBHOOK}}" placeholder="http://scrypted-ip:11080/endpoint/your-id/public/">
            <div style="padding: 0 8px 12px 8px; font-size: 0.9em; color: #666;">
                Get this from Scrypted doorbell device settings. Leave empty to disable HomeKit ring.
            </div>
            <div class="button-row button-grid" style="margin-top: 8px;">
                <button class="button btn-test" title="Trigger the doorbell flow without SIP ringing." onclick="testHomekitGong()">üîî HomeKit Test Gong</button>
            </div>

            <div class="flash-stats" style="margin-top: 12px;">
                <strong>Recommended Source URL:</strong>
                <p style="font-family: monospace; font-size: 0.9em; word-break: break-all;" id="scrypted_source_url"></p>
            </div>
            <div class="flash-stats">
                <strong>FFmpeg Input Args:</strong>
                <p style="font-family: monospace; font-size: 0.9em; word-break: break-all;" id="scrypted_input_args"></p>
            </div>
            <div class="flash-stats">
                <strong>FFmpeg Output Prefix:</strong>
                <p style="font-family: monospace; font-size: 0.9em; word-break: break-all;" id="scrypted_output_prefix"></p>
            </div>
        </div>

        <div class="container card setup-card">
            <h3 class="card-title">‚¨ÜÔ∏è OTA Updates</h3>
            <div class="flash-stats" id="otaStatus">
                <strong>Status:</strong> loading...
            </div>

            <label><strong>OTA Username</strong></label>
            <input type="text" id="ota_user" placeholder="admin">

            <label><strong>Current Password</strong></label>
            <input type="password" id="ota_current_pass" placeholder="Required to update credentials">

            <label><strong>New Password</strong></label>
            <input type="password" id="ota_pass" placeholder="Strong password">

            <label><strong>Confirm New Password</strong></label>
            <input type="password" id="ota_pass_confirm" placeholder="Re-enter new password">

            <div class="button-row button-grid" style="margin-top: 12px;">
                <button class="button btn-save" title="Save or update OTA credentials." onclick="saveOtaConfig()">Save OTA Credentials</button>
                <button class="button btn-save" title="Enable OTA uploads for 5 minutes." onclick="enableOta()">Enable OTA (5 min)</button>
                <a class="button btn-nav" href="/ota" target="_blank" title="Open the OTA upload page.">Open OTA Page</a>
            </div>
            <div class="ota-note">
                OTA uploads are local-network only and require the credentials above.
            </div>
        </div>
    </div>

    <div class="button-row button-grid log-actions" style="margin-top: 20px;">
        <button class="button btn-save" title="Save feature toggles and restart." onclick="saveFeatures()">üíæ Save Features</button>
        <button class="button danger-btn" title="Reboot the ESP32 device." onclick="confirmRestart()">üîÑ Restart</button>
        <a class="button btn-info" href="/logs.html?filter=core" target="_blank" title="Open filtered core logs.">üîß Core Logs</a>
        <a class="button btn-info" href="/logs.html?filter=camera" target="_blank" title="Open filtered camera/streaming logs.">üìπ Camera Logs</a>

        <a class="button btn-info" href="/logs.html?filter=doorbell" target="_blank" title="Open filtered doorbell/SIP/TR-064 logs.">‚òéÔ∏è Doorbell Logs</a>
        <a class="button btn-nav" href="/" title="Return to the main dashboard.">Back</a>
    </div>

    <script>
        const darkToggle = document.getElementById("darkModeToggle");
        function setDarkMode(enabled) {
            document.body.classList.toggle("dark-mode", enabled);
            localStorage.setItem("darkMode", enabled ? "enabled" : "disabled");
        }
        const savedDarkMode = localStorage.getItem("darkMode");
        const darkModeEnabled = savedDarkMode === null ? true : savedDarkMode === "enabled";
        darkToggle.checked = darkModeEnabled;
        setDarkMode(darkModeEnabled);
        darkToggle.addEventListener("change", () => {
            setDarkMode(darkToggle.checked);
        });

        function saveFeatures() {
            if (!validateScryptedOptions()) {
                alert("Scrypted options are invalid. Enable the required stream type.");
                return;
            }
            showConfirm(
                "\ud83d\udcbe Confirm Save Features",
                buildChangeSummary() + "<p style='margin:12px 0 0;color:#888;font-size:0.85em;'>Saves all settings and reloads the page.</p>",
                doSaveFeatures
            );
        }

        function doSaveFeatures() {
            const features = {
                timezone: document.getElementById("timezone").value,
                sip_enabled: document.getElementById("sip_enabled").checked,
                tr064_enabled: document.getElementById("tr064_enabled").checked,
                http_cam_enabled: document.getElementById("http_cam_enabled").checked,
                rtsp_enabled: document.getElementById("rtsp_enabled").checked,
                http_cam_max_clients: parseInt(document.getElementById("http_cam_max_clients").value || "2", 10),
                scrypted_source: document.querySelector("input[name='scrypted_source']:checked")?.value || "http",
                scrypted_webhook: document.getElementById("scrypted_webhook").value.trim(),
                scrypted_low_latency: document.getElementById("scrypted_low_latency").checked,
                scrypted_low_buffer: document.getElementById("scrypted_low_buffer").checked,
                scrypted_rtsp_udp: document.getElementById("scrypted_rtsp_udp").checked,
                framesize: parseInt(document.getElementById("framesize").value, 10),
                quality: parseInt(document.getElementById("quality").value, 10),
                brightness: parseInt(document.getElementById("brightness").value, 10),
                contrast: parseInt(document.getElementById("contrast").value, 10),
                mic_enabled: document.getElementById("mic_enabled").checked,
                mic_muted: document.getElementById("mic_muted").checked,
                mic_sensitivity: parseInt(document.getElementById("mic_sensitivity").value || "70", 10),
                mic_source: parseInt(document.getElementById("mic_source").value || "0", 10),
                aac_sample_rate: parseInt(document.getElementById("aac_sample_rate").value || "16", 10),
                aac_bitrate: parseInt(document.getElementById("aac_bitrate").value || "32", 10),
                audio_out_enabled: document.getElementById("audio_out_enabled").checked,
                audio_out_muted: document.getElementById("audio_out_muted").checked,
                hardware_diag_mode: document.getElementById("hardware_diag_mode").checked,
                audio_out_volume: parseInt(document.getElementById("audio_out_volume").value || "70", 10)
            };
            fetch("/saveFeatures", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(features)
            }).then(r => r.text())
              .then(t => { alert(t); setTimeout(() => window.location.reload(), 1000); })
              .catch(e => alert("Save failed: " + e));
        }

        function testHomekitGong() {
            fetch("/ring/homekit")
                .then(r => r.text())
                .then(t => alert(t))
                .catch(e => alert("HomeKit test failed: " + e));
        }

        function testMic() {
            var btn = document.getElementById("testMicBtn");
            var result = document.getElementById("micTestResult");
            btn.disabled = true;
            btn.textContent = "üé§ Recording...";
            result.style.display = "none";
            fetch("/api/mic/test", { method: "POST" })
                .then(function(r) { return r.json(); })
                .then(function(d) {
                    if (d.error) {
                        result.textContent = "‚ö†Ô∏è " + d.error;
                    } else {
                        var noSignal = d.zero_pct >= 99;
                        result.textContent =
                            "Source: " + d.source +
                            " | Peak: " + d.peak_pct + "%" +
                            " | RMS: " + d.rms +
                            " | Zeros: " + d.zero_pct + "%" +
                            " | Sensitivity: " + d.sensitivity + "%" +
                            (d.played_back ? " | ‚úÖ Played back" : " | ‚ö†Ô∏è Playback failed") +
                            (noSignal ? " | ‚ö†Ô∏è No mic signal ‚Äî check wiring or switch to PDM" : "");
                    }
                    result.style.display = "block";
                })
                .catch(function(e) {
                    result.textContent = "‚ö†Ô∏è " + e.message;
                    result.style.display = "block";
                })
                .finally(function() {
                    btn.disabled = false;
                    btn.textContent = "üé§ Record & Play";
                });
        }

        function testLocalGong() {
            fetch("/api/audio/gong", { method: "POST" })
                .then(async (r) => {
                    const text = await r.text();
                    if (!r.ok) {
                        throw new Error(text || `HTTP ${r.status}`);
                    }
                    return text;
                })
                .then(t => {
                    try {
                        const j = JSON.parse(t);
                        alert(j.message || "Gong triggered");
                    } catch {
                        alert(t || "Gong triggered");
                    }
                })
                .catch(e => alert("Local gong test failed: " + e.message));
        }

        let _audioSaveTimer = null;
        var rebootRequired = false;

        function debouncedAudioSave() {
            clearTimeout(_audioSaveTimer);
            _audioSaveTimer = setTimeout(autoSaveAudioMic, 400);
        }

        // --- Confirmation modal ---
        // okClass: optional CSS class for confirm button (default "btn-save"; use "danger-btn" for destructive)
        function showConfirm(title, bodyHTML, onConfirm, okClass) {
            document.getElementById("confirmTitle").textContent = title;
            document.getElementById("confirmBody").innerHTML = bodyHTML;
            document.getElementById("confirmOkBtn").className = "button " + (okClass || "btn-save");
            document.getElementById("confirmOkBtn").onclick = function() { closeConfirm(); onConfirm(); };
            document.getElementById("confirmModal").style.display = "flex";
        }
        function closeConfirm() {
            document.getElementById("confirmModal").style.display = "none";
        }
        function escapeHtml(s) {
            return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
        }

        // --- Change tracking for Save Features dialog ---
        var initialValues = {};
        var _fieldLabels = {
            timezone:"Timezone", sip_enabled:"SIP", tr064_enabled:"TR-064",
            http_cam_enabled:"HTTP Camera", rtsp_enabled:"RTSP",
            http_cam_max_clients:"Max MJPEG Clients",
            framesize:"Frame Size", quality:"JPEG Quality",
            brightness:"Brightness", contrast:"Contrast",
            audio_out_enabled:"Audio Output", audio_out_muted:"Speaker Muted",
            audio_out_volume:"Speaker Volume", hardware_diag_mode:"HW Diagnostic Mode",
            mic_enabled:"Mic Enabled", mic_muted:"Mic Muted",
            mic_source:"Mic Source", mic_sensitivity:"Mic Sensitivity",
            aac_sample_rate:"AAC Sample Rate", aac_bitrate:"AAC Bitrate",
            scrypted_source:"Scrypted Source", scrypted_webhook:"HomeKit Webhook",
            scrypted_low_latency:"Low Latency", scrypted_low_buffer:"Reduce Buffering",
            scrypted_rtsp_udp:"RTSP UDP"
        };
        function snapshotInitialValues() {
            Object.keys(_fieldLabels).forEach(function(id) {
                if (id === "scrypted_source") {
                    var r = document.querySelector("input[name='scrypted_source']:checked");
                    initialValues[id] = r ? r.value : "http";
                } else {
                    var el = document.getElementById(id);
                    if (el) initialValues[id] = el.type === "checkbox" ? el.checked : el.value;
                }
            });
        }
        function buildChangeSummary() {
            var changes = [];
            Object.keys(_fieldLabels).forEach(function(id) {
                var cur;
                if (id === "scrypted_source") {
                    var r = document.querySelector("input[name='scrypted_source']:checked");
                    cur = r ? r.value : "http";
                } else {
                    var el = document.getElementById(id);
                    if (!el) return;
                    cur = el.type === "checkbox" ? el.checked : el.value;
                }
                var orig = initialValues[id];
                if (orig !== undefined && String(cur) !== String(orig)) {
                    var disp = function(v) { return v === true ? "Yes" : v === false ? "No" : escapeHtml(String(v)); };
                    changes.push("<li><strong>" + _fieldLabels[id] + "</strong>: " + disp(orig) + " \u2192 " + disp(cur) + "</li>");
                }
            });
            if (!changes.length) return "<p style='color:#888;font-style:italic;'>No changes since page loaded.</p>";
            return "<ul style='margin:4px 0;padding-left:20px;'>" + changes.join("") + "</ul>";
        }

        function confirmRestart() {
            var body = rebootRequired
                ? "<p>\u26a0\ufe0f Reboot required for <strong>Mic Source</strong> change to take effect.</p><p>Restart the device now?</p>"
                : "<p>Restart the device now?</p>";
            showConfirm("\ud83d\udd04 Confirm Restart", body, function() { location.href = '/restart'; }, "danger-btn");
        }

        function autoSaveAudioMic() {
            clearTimeout(_audioSaveTimer);
            const statusEl = document.getElementById("audioSaveStatus");
            const data = {
                audio_out_muted:    document.getElementById("audio_out_muted").checked,
                audio_out_volume:   parseInt(document.getElementById("audio_out_volume").value || "70", 10),
                hardware_diag_mode: document.getElementById("hardware_diag_mode").checked,
                mic_enabled:        document.getElementById("mic_enabled").checked,
                mic_muted:          document.getElementById("mic_muted").checked,
                mic_source:         parseInt(document.getElementById("mic_source").value || "0", 10),
                mic_sensitivity:    parseInt(document.getElementById("mic_sensitivity").value || "70", 10),
                aac_sample_rate:    parseInt(document.getElementById("aac_sample_rate").value || "16", 10),
                aac_bitrate:        parseInt(document.getElementById("aac_bitrate").value || "32", 10)
            };
            fetch("/saveFeatures", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data)
            }).then(function(r) { return r.text(); })
              .then(function() {
                  if (statusEl) {
                      if (rebootRequired) {
                          statusEl.textContent = "\u26a0\ufe0f Reboot required";
                          statusEl.style.color = "#e65100";
                          statusEl.style.opacity = "1";
                      } else {
                          statusEl.textContent = "\u2713 Saved";
                          statusEl.style.color = "";
                          statusEl.style.opacity = "1";
                          setTimeout(function() { statusEl.style.opacity = "0"; }, 2000);
                      }
                  }
              })
              .catch(function(e) {
                  if (statusEl) {
                      statusEl.textContent = "‚úó Error";
                      statusEl.style.opacity = "1";
                      setTimeout(function() { statusEl.style.opacity = "0"; }, 3000);
                  }
                  console.error("Audio/Mic auto-save failed:", e);
              });
        }

        const cameraSetupStatusEl = document.getElementById("cameraSetupStatus");
        const qualityValueEl = document.getElementById("qualityValue");
        const brightnessValueEl = document.getElementById("brightnessValue");
        const contrastValueEl = document.getElementById("contrastValue");
        const scryptedStatusEl = document.getElementById("scryptedStatus");
        const scryptedSourceUrlEl = document.getElementById("scrypted_source_url");
        const scryptedInputArgsEl = document.getElementById("scrypted_input_args");
        const scryptedOutputPrefixEl = document.getElementById("scrypted_output_prefix");
        const micSensitivityValueEl = document.getElementById("micSensitivityValue");
        const aacRateEl = document.getElementById("aac_sample_rate");
        const aacBitrateEl = document.getElementById("aac_bitrate");
        const aacBitrateValueEl = document.getElementById("aacBitrateValue");
        const audioOutVolumeValueEl = document.getElementById("audioOutVolumeValue");
        const otaStatusEl = document.getElementById("otaStatus");
        const otaUserEl = document.getElementById("ota_user");
        const otaCurrentPassEl = document.getElementById("ota_current_pass");
        const otaPassEl = document.getElementById("ota_pass");
        const otaPassConfirmEl = document.getElementById("ota_pass_confirm");
        let otaKnownUser = "";

        function formatMs(ms) {
            if (!ms || ms <= 0) return "0s";
            const sec = Math.floor(ms / 1000);
            if (sec < 60) return `${sec}s`;
            const min = Math.floor(sec / 60);
            const rem = sec % 60;
            return `${min}m ${rem}s`;
        }

        function isStrongPassword(password) {
            return password.length >= 12 &&
                   /[a-z]/.test(password) &&
                   /[A-Z]/.test(password) &&
                   /[0-9]/.test(password) &&
                   /[^A-Za-z0-9]/.test(password);
        }

        function buildOtaAuthHeader() {
            const user = otaKnownUser || otaUserEl.value.trim();
            const pass = otaCurrentPassEl.value;
            if (!user || !pass) return null;
            return "Basic " + btoa(`${user}:${pass}`);
        }

        function updateRangeDisplay(input, label) {
            if (!input || !label) return;
            const min = parseFloat(input.min || "0");
            const max = parseFloat(input.max || "100");
            const val = parseFloat(input.value || "0");
            const percent = max > min ? ((val - min) / (max - min)) * 100 : 0;
            const labelPercent = Math.min(95, Math.max(5, percent));
            const unit = input.dataset.unit || "";
            label.textContent = `${val}${unit}`;
            const wrap = input.closest(".range-wrap");
            if (wrap) {
                wrap.style.setProperty("--range-percent", `${percent}%`);
                wrap.style.setProperty("--range-label", `${labelPercent}%`);
            }
        }

        function bindRange(inputId, labelId) {
            const input = document.getElementById(inputId);
            const label = document.getElementById(labelId);
            if (!input || !label) return;
            const update = () => updateRangeDisplay(input, label);
            input.addEventListener("input", update);
            update();
        }

        function applyAacBitrateBounds() {
            if (!aacRateEl || !aacBitrateEl || !aacBitrateValueEl) return;
            const rate = parseInt(aacRateEl.value || "16", 10);
            const is8k = rate === 8;
            const min = is8k ? 16 : 24;
            const max = is8k ? 32 : 48;
            aacBitrateEl.min = String(min);
            aacBitrateEl.max = String(max);
            let val = parseInt(aacBitrateEl.value || String(min), 10);
            if (val < min) val = min;
            if (val > max) val = max;
            aacBitrateEl.value = String(val);
            updateRangeDisplay(aacBitrateEl, aacBitrateValueEl);
        }

        function fetchOtaStatus() {
            fetch("/ota/status", { credentials: "include" })
                .then(r => {
                    if (r.status === 401) {
                        otaStatusEl.innerHTML = "<strong>Status:</strong> enter OTA credentials to view status";
                        return null;
                    }
                    if (!r.ok) {
                        otaStatusEl.innerHTML = "<strong>Status:</strong> unavailable";
                        return null;
                    }
                    return r.json();
                })
                .then(data => {
                    if (!data) return;
                    otaKnownUser = data.username || otaKnownUser;
                    if (data.username) {
                        otaUserEl.value = data.username;
                    }
                    const configured = data.configured ? "configured" : "not configured";
                    const enabled = data.enabled
                        ? `enabled (${formatMs(data.remaining_ms)})`
                        : "disabled";
                    otaStatusEl.innerHTML = `<strong>Status:</strong> ${configured} | ${enabled}`;
                })
                .catch(() => {
                    otaStatusEl.innerHTML = "<strong>Status:</strong> unavailable";
                });
        }

        function saveOtaConfig() {
            const username = otaUserEl.value.trim();
            const password = otaPassEl.value;
            const confirm = otaPassConfirmEl.value;

            if (!username) { alert("OTA username is required."); return; }
            if (password !== confirm) { alert("New passwords do not match."); return; }
            if (!isStrongPassword(password)) {
                alert("Password must be at least 12 characters and include upper, lower, digit, and symbol.");
                return;
            }
            showConfirm(
                "\ud83d\udd11 Confirm OTA Credentials",
                "<p>Update OTA credentials?</p><ul style='margin:4px 0;padding-left:20px;'>" +
                "<li>Username: <strong>" + escapeHtml(username) + "</strong></li>" +
                "<li>Password: \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022</li></ul>",
                function() { doSaveOtaConfig(username, password); }
            );
        }

        function doSaveOtaConfig(username, password) {
            const headers = { "Content-Type": "application/json" };
            const authHeader = buildOtaAuthHeader();
            if (authHeader) headers["Authorization"] = authHeader;
            fetch("/ota/config", {
                method: "POST",
                headers,
                body: JSON.stringify({ username, password })
            }).then(r => r.text())
              .then(t => { alert(t); otaCurrentPassEl.value = ""; fetchOtaStatus(); })
              .catch(e => alert("OTA save failed: " + e));
        }

        function enableOta() {
            const headers = {};
            const authHeader = buildOtaAuthHeader();
            if (authHeader) {
                headers["Authorization"] = authHeader;
            } else {
                alert("Enter current OTA password to enable OTA.");
                return;
            }

            fetch("/ota/enable", {
                method: "POST",
                headers
            }).then(r => r.text())
              .then(t => {
                  alert(t);
                  fetchOtaStatus();
              })
              .catch(e => alert("OTA enable failed: " + e));
        }

        function fetchCameraSetupStatus() {
            fetch("/status", { cache: "no-store" })
                .then(r => r.json())
                .then(data => {
                    cameraSetupStatusEl.innerHTML = `<strong>Camera:</strong> ${data.PID || "Unknown"} | size=${data.framesize} | quality=${data.quality}`;
                    if (data.framesize !== undefined) {
                        document.getElementById("framesize").value = data.framesize;
                    }
                    if (data.quality !== undefined) {
                        document.getElementById("quality").value = data.quality;
                        updateRangeDisplay(document.getElementById("quality"), qualityValueEl);
                    }
                    if (data.brightness !== undefined) {
                        document.getElementById("brightness").value = data.brightness;
                        updateRangeDisplay(document.getElementById("brightness"), brightnessValueEl);
                    }
                    if (data.contrast !== undefined) {
                        document.getElementById("contrast").value = data.contrast;
                        updateRangeDisplay(document.getElementById("contrast"), contrastValueEl);
                    }
                    if (data.mic_enabled !== undefined) {
                        document.getElementById("mic_enabled").checked = data.mic_enabled;
                    }
                    if (data.mic_muted !== undefined) {
                        document.getElementById("mic_muted").checked = data.mic_muted;
                    }
                    if (data.mic_sensitivity !== undefined) {
                        document.getElementById("mic_sensitivity").value = data.mic_sensitivity;
                        updateRangeDisplay(document.getElementById("mic_sensitivity"), micSensitivityValueEl);
                    }
                    if (data.aac_sample_rate !== undefined) {
                        document.getElementById("aac_sample_rate").value = data.aac_sample_rate;
                    }
                    if (data.mic_source !== undefined) {
                        document.getElementById("mic_source").value = data.mic_source;
                    }
                    if (data.aud_volume !== undefined) {
                        document.getElementById("audio_out_volume").value = data.aud_volume;
                        updateRangeDisplay(document.getElementById("audio_out_volume"), audioOutVolumeValueEl);
                    }
                    if (data.hardware_diag_mode !== undefined) {
                        document.getElementById("hardware_diag_mode").checked = data.hardware_diag_mode;
                    }
                    if (data.aac_bitrate !== undefined) {
                        document.getElementById("aac_bitrate").value = data.aac_bitrate;
                        applyAacBitrateBounds();
                    }
                    if (data.speaker_available === false) {
                        document.getElementById("audio_out_enabled").disabled = true;
                        document.getElementById("audio_out_volume").disabled = true;
                        document.getElementById("audio_out_muted").disabled = true;
                    }
                    updateAudioUi();
                })
                .catch(() => {
                    cameraSetupStatusEl.innerHTML = "<strong>Camera:</strong> unavailable";
                });
        }

        bindRange("quality", "qualityValue");
        bindRange("brightness", "brightnessValue");
        bindRange("contrast", "contrastValue");
        bindRange("mic_sensitivity", "micSensitivityValue");
        bindRange("aac_bitrate", "aacBitrateValue");
        bindRange("audio_out_volume", "audioOutVolumeValue");

        if (aacRateEl) {
            aacRateEl.addEventListener("change", function() {
                applyAacBitrateBounds();
                autoSaveAudioMic();
            });
        }
        applyAacBitrateBounds();

        function updateAudioUi() {
            const micEnabled = document.getElementById("mic_enabled").checked;
            document.getElementById("mic_muted").disabled = !micEnabled;
            document.getElementById("mic_sensitivity").disabled = !micEnabled;

            // Note: audio_out_volume is always interactive ‚Äî you should be able to
            // set the volume independently of the audio_out_enabled feature toggle.
            const audioOutEnabled = document.getElementById("audio_out_enabled").checked;
            document.getElementById("audio_out_muted").disabled = !audioOutEnabled;
        }

        function getScryptedSource() {
            const selected = document.querySelector("input[name='scrypted_source']:checked");
            return selected ? selected.value : "http";
        }

        function buildScryptedOutputPrefix() {
            const lowLatency = document.getElementById("scrypted_low_latency").checked;
            const gop = lowLatency ? 30 : 60;
            return `-c:v libx264 -pix_fmt yuvj420p -preset ultrafast -bf 0 -g ${gop} -r 15 -b:v 500000 -bufsize 1000000 -maxrate 500000`;
        }

        function buildScryptedInputArgs() {
            const source = getScryptedSource();
            const lowBuffer = document.getElementById("scrypted_low_buffer").checked;
            const preferUdp = document.getElementById("scrypted_rtsp_udp").checked;
            const args = [];
            if (source === "rtsp") {
                args.push(`-rtsp_transport ${preferUdp ? "udp" : "tcp"}`);
            }
            if (lowBuffer) {
                args.push("-fflags nobuffer -flags low_delay -analyzeduration 0 -probesize 32");
            }
            return args.length ? args.join(" ") : "(none)";
        }

        function updateScryptedUi() {
            const httpRadio = document.getElementById("scrypted_source_http");
            const rtspRadio = document.getElementById("scrypted_source_rtsp");
            const rtspEnabled = document.getElementById("rtsp_enabled").checked;
            const httpEnabled = document.getElementById("http_cam_enabled").checked;

            httpRadio.disabled = !httpEnabled;
            rtspRadio.disabled = !rtspEnabled;

            if (!httpEnabled && rtspEnabled) {
                rtspRadio.checked = true;
            } else if (!rtspEnabled && httpEnabled) {
                httpRadio.checked = true;
            }

            const source = getScryptedSource();
            const ip = "{{LOCAL_IP}}";
            const sourceUrl = source === "rtsp"
                ? `rtsp://${ip}:8554/mjpeg/1`
                : `http://${ip}:81/stream`;
            scryptedSourceUrlEl.textContent = sourceUrl;
            scryptedInputArgsEl.textContent = buildScryptedInputArgs();
            scryptedOutputPrefixEl.textContent = buildScryptedOutputPrefix();

            const rtspUdpEl = document.getElementById("scrypted_rtsp_udp");
            rtspUdpEl.disabled = source !== "rtsp";

            let status = "OK";
            if (!httpEnabled && !rtspEnabled) {
                status = "Enable HTTP or RTSP streaming to use Scrypted.";
            } else if (source === "rtsp" && !rtspEnabled) {
                status = "Enable RTSP streaming to use RTSP source.";
            } else if (source === "http" && !httpEnabled) {
                status = "Enable HTTP streaming to use HTTP source.";
            }
            scryptedStatusEl.innerHTML = `<strong>Status:</strong> ${status}`;
        }

        function validateScryptedOptions() {
            const source = getScryptedSource();
            const rtspEnabled = document.getElementById("rtsp_enabled").checked;
            const httpEnabled = document.getElementById("http_cam_enabled").checked;
            // If neither streaming type is enabled, Scrypted isn't in use ‚Äî skip validation
            if (!httpEnabled && !rtspEnabled) return true;
            if (source === "rtsp" && !rtspEnabled) {
                return false;
            }
            if (source === "http" && !httpEnabled) {
                return false;
            }
            return true;
        }

        document.querySelectorAll("input[name='scrypted_source']").forEach((el) => {
            el.addEventListener("change", updateScryptedUi);
        });
        document.getElementById("scrypted_low_latency").addEventListener("change", updateScryptedUi);
        document.getElementById("scrypted_low_buffer").addEventListener("change", updateScryptedUi);
        document.getElementById("scrypted_rtsp_udp").addEventListener("change", updateScryptedUi);
        document.getElementById("rtsp_enabled").addEventListener("change", updateScryptedUi);
        document.getElementById("http_cam_enabled").addEventListener("change", updateScryptedUi);
        document.getElementById("mic_enabled").addEventListener("change", updateAudioUi);
        document.getElementById("audio_out_enabled").addEventListener("change", updateAudioUi);
        // Set selected timezone (legacy template fallback)
        const timezoneFallback = "{{TIMEZONE}}";
        if (timezoneFallback && !timezoneFallback.includes("{{")) {
            document.getElementById("timezone").value = timezoneFallback;
        }

        function loadFeatures() {
            fetch("/api/features", { cache: "no-store" })
                .then(r => r.json())
                .then(data => {
                    if (data.timezone !== undefined) {
                        document.getElementById("timezone").value = data.timezone;
                    }
                    if (data.sip_enabled !== undefined) {
                        document.getElementById("sip_enabled").checked = data.sip_enabled;
                    }
                    if (data.tr064_enabled !== undefined) {
                        document.getElementById("tr064_enabled").checked = data.tr064_enabled;
                    }
                    if (data.http_cam_enabled !== undefined) {
                        document.getElementById("http_cam_enabled").checked = data.http_cam_enabled;
                    }
                    if (data.rtsp_enabled !== undefined) {
                        document.getElementById("rtsp_enabled").checked = data.rtsp_enabled;
                    }
                    if (data.audio_out_enabled !== undefined) {
                        document.getElementById("audio_out_enabled").checked = data.audio_out_enabled;
                    }
                    if (data.audio_out_muted !== undefined) {
                        document.getElementById("audio_out_muted").checked = data.audio_out_muted;
                    }
                    if (data.hardware_diag_mode !== undefined) {
                        document.getElementById("hardware_diag_mode").checked = data.hardware_diag_mode;
                    }
                    updateScryptedUi();
                    updateAudioUi();
                })
                .catch(e => console.error("Failed to load features:", e));
        }

        // Auto-save listeners for Audio/Mic card ‚Äî changes apply immediately, no Save button needed
        ["audio_out_muted", "hardware_diag_mode", "mic_enabled", "mic_muted"].forEach(function(id) {
            var el = document.getElementById(id);
            if (el) el.addEventListener("change", autoSaveAudioMic);
        });
        document.getElementById("mic_source").addEventListener("change", function() {
            rebootRequired = true;
            autoSaveAudioMic();
            var statusEl = document.getElementById("audioSaveStatus");
            if (statusEl) {
                statusEl.textContent = "\u26a0\ufe0f Reboot required";
                statusEl.style.color = "#e65100";
                statusEl.style.opacity = "1";
            }
        });
        // Range sliders: fire on input (while dragging, debounced) and on change
        // (mouse/touch release) as a reliable fallback for browsers that don't
        // fire input continuously.
        ["audio_out_volume", "mic_sensitivity", "aac_bitrate"].forEach(function(id) {
            var el = document.getElementById(id);
            if (el) {
                el.addEventListener("input", debouncedAudioSave);
                el.addEventListener("change", autoSaveAudioMic);
            }
        });

        fetchCameraSetupStatus();
        updateScryptedUi();
        updateAudioUi();
        fetchOtaStatus();
        loadFeatures();
        // Snapshot field values after both async fetches complete (local network < 200ms each)
        setTimeout(snapshotInitialValues, 800);
    </script>

<style>
@media (prefers-color-scheme: dark) {
    #confirmBox { background: #2d2d2d !important; color: #e0e0e0 !important; }
    #confirmBox button[onclick="closeConfirm()"] { background: #555 !important; }
}
</style>
<div id="confirmModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
    <div id="confirmBox" style="background:#fff;color:#333;padding:24px;border-radius:8px;max-width:480px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,0.3);max-height:80vh;overflow-y:auto;">
        <h3 id="confirmTitle" style="margin:0 0 12px;font-size:1.1em;"></h3>
        <div id="confirmBody" style="margin-bottom:20px;font-size:0.9em;line-height:1.6;"></div>
        <div style="display:flex;gap:10px;justify-content:flex-end;">
            <button class="button" style="background:#9e9e9e;color:#fff;" onclick="closeConfirm()">Cancel</button>
            <button id="confirmOkBtn" class="button btn-save">Confirm</button>
        </div>
    </div>
</div>
</body>
</html>
